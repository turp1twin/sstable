/**
 * Represents the immutable map from string to a list of strings with fast assoc access.
 * The key set need not fit in memory, both building and searching for values are lazy.
 */

import java.io.{RandomAccessFile => RAF, File}
import scala.collection.SortedMap

// The input file comes in ascending keys order in blocks of blockSize keys. Each block has the format:
// pos of the next block
// pos*blockSize
// records of the form (key, nValues, values)
class SSTable(f: File) {
  import SSTable.blockSize

  lazy val in = new RAF(f, "r")

  def apply(key: String): Option[List[String]] = {
    val slice = blockMap.to(key)
    if (slice.isEmpty) None else {
      val (_, offset) = slice.max
      val stream = Stream.tabulate(blockSize){ i =>
        in.seek(offset + 8 * i)
        in.readLong
      } takeWhile (-1 !=)

      val trunc = stream map { offset =>
        in.seek(offset)
        (in.readUTF, Stream.fill(in.readInt)(in.readUTF))
      } dropWhile (_._1 < key)

      trunc.headOption flatMap {
        case (k, vs) => if (k == key) Some(vs.toList) else None
      }
    }
  }

  lazy val blockMap: SortedMap[String, Long] = {
    val stream = Stream.iterate(0L) { offset =>
      in.seek(offset)
      in.readLong
    } takeWhile (-1L !=) map { offset =>
      in.seek(offset + 8 * (blockSize + 1))
      (in.readUTF, offset + 8)
    }
    SortedMap(stream: _*)
  }
}

object SSTable {
  val blockSize = 128

  def write(parts: List[Stream[(String, String)]], f: File): SSTable = {
    val raf = new RAF(f, "rw")

    implicit val ord = Ordering[String].on[(String, String)](_._1)
    val merger = new StreamMerger[(String, String)]
    val merged = merger mergeSort parts

    @annotation.tailrec
    def iter(stream: Stream[(String, String)], offset: Long) {
      if (!stream.isEmpty) {
        raf.seek(offset)
        // Write garbage to be overwritten.
        raf.writeLong(-1L)
        for (_ <- 0 until blockSize) raf.writeLong(-1L)

        val (tail, offsets) = (0 until blockSize).foldLeft(Pair(stream, List[Long]())) {
          case ((stream, offsets), i) =>
            stream match {
              case (k, _)#::_=>
                val (first, rest) = stream span (_._1 == k)
                val end = raf.length
                val vs = first.toList map (_._2)
                raf.writeUTF(k)
                raf.writeInt(vs.length)
                for (v <- vs) raf.writeUTF(v)
                (rest, end::offsets)
              case _ => (stream, -1L::offsets)
            }
          }
        raf.seek(offset)
        raf.writeLong(if (tail.isEmpty) -1L else raf.length)
        for (offset <- offsets.reverse) raf.writeLong(offset)
        iter(tail, raf.length)
      }
    }
    iter(merged, 0L)

    raf.close()

    new SSTable(f)
  }
}
